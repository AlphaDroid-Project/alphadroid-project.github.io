<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>AlphaDroid Banner Generator Demo</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <!-- Fonts (site already uses Roboto Flex; include here for standalone demo use) -->
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;500;600;700&display=swap"
            rel="stylesheet"
        />
        <style>
            :root {
                --bg: #0f1115;
                --fg: #e8e6ef;
                --muted: #b7b4c4;
                --card: #171a20;
                --accent: #7c6ef6;
                --accent-2: #9c92ff;
                --border: rgba(255, 255, 255, 0.08);
                --radius: 16px;
            }
            * {
                box-sizing: border-box;
                font-family:
                    "Fredoka",
                    system-ui,
                    -apple-system,
                    Segoe UI,
                    Roboto,
                    "Helvetica Neue",
                    Arial,
                    sans-serif;
            }
            html,
            body {
                margin: 0;
                padding: 0;
                height: 100%;
                background: var(--bg);
                color: var(--fg);
            }
            header {
                padding: 24px;
            }
            header h1 {
                margin: 0 0 6px;
                font-size: 22px;
                font-weight: 800;
                letter-spacing: 0.2px;
            }
            header p {
                margin: 0;
                color: var(--muted);
                font-size: 13px;
            }
            main {
                display: grid;
                gap: 20px;
                grid-template-columns: 380px 1fr;
                padding: 0 24px 24px;
            }
            @media (max-width: 980px) {
                main {
                    grid-template-columns: 1fr;
                }
            }

            .card {
                background: var(--card);
                border: 1px solid var(--border);
                border-radius: var(--radius);
                padding: 16px;
            }

            form .group {
                margin-bottom: 14px;
            }
            form label {
                display: block;
                font-size: 12px;
                color: var(--muted);
                margin-bottom: 6px;
            }
            form input[type="text"],
            form input[type="number"],
            form input[type="url"],
            form textarea,
            form select {
                width: 100%;
                background: #0f1217;
                color: var(--fg);
                border: 1px solid var(--border);
                border-radius: 10px;
                padding: 10px 12px;
                outline: none;
                font-size: 14px;
            }
            form textarea {
                resize: vertical;
                min-height: 60px;
            }
            form input[type="checkbox"] {
                width: auto;
                margin-right: 8px;
                cursor: pointer;
                accent-color: var(--accent);
            }
            form label:has(input[type="checkbox"]) {
                display: flex;
                align-items: flex-start;
                font-size: 13px;
                cursor: pointer;
                color: var(--fg);
            }

            .row {
                display: flex;
                gap: 10px;
                align-items: center;
            }
            .row > * {
                flex: 1;
            }

            .hint {
                color: var(--muted);
                font-size: 12px;
                margin-top: 6px;
            }

            .buttons {
                display: flex;
                gap: 10px;
                flex-wrap: wrap;
                margin-top: 6px;
            }
            button {
                background: var(--accent);
                color: white;
                border: 0;
                padding: 10px 14px;
                border-radius: 12px;
                font-weight: 700;
                cursor: pointer;
                transition:
                    transform 0.12s ease,
                    box-shadow 0.12s ease,
                    background 0.12s ease;
                box-shadow: 0 6px 16px rgba(124, 110, 246, 0.35);
            }
            button:hover {
                transform: translateY(-1px);
                background: var(--accent-2);
            }
            button.secondary {
                background: transparent;
                color: var(--fg);
                border: 1px solid var(--border);
                box-shadow: none;
            }
            button:disabled {
                opacity: 0.5;
                cursor: default;
                transform: none;
            }

            .preview-wrap {
                display: grid;
                gap: 14px;
                grid-template-rows: auto 1fr;
            }
            .preview-actions {
                display: flex;
                gap: 10px;
                align-items: center;
                justify-content: space-between;
            }
            .preview-area {
                min-height: 200px;
                display: grid;
                place-items: center;
                overflow: auto;
                background: #0b0d12;
                border: 1px dashed var(--border);
                border-radius: 12px;
                padding: 10px;
                /* Use max-height to avoid overly large preview panels on tall screens */
                max-height: 70vh;
                min-height: 240px;
            }
            .preview-area canvas {
                max-width: 100%;
                max-height: 100%;
                width: auto;
                height: auto;
                display: block;
                border-radius: 8px;
                box-shadow:
                    0 10px 30px rgba(0, 0, 0, 0.5),
                    0 0 0 1px rgba(255, 255, 255, 0.04) inset;
                object-fit: contain;
            }
            .small {
                font-size: 12px;
                color: var(--muted);
            }
            .badge {
                display: inline-block;
                padding: 4px 10px;
                border-radius: 999px;
                background: rgba(255, 255, 255, 0.08);
                color: var(--fg);
                font-size: 12px;
                border: 1px solid var(--border);
            }
        </style>
    </head>
    <body>
        <header>
            <h1>AlphaDroid Banner Generator</h1>
            <p>
                Demo page to overlay the text skeleton on a template and export
                as PNG.
            </p>
        </header>

        <main>
            <!-- Controls -->
            <section class="card">
                <form id="controls" novalidate>
                    <div class="group">
                        <label>Device</label>
                        <div style="display:flex;gap:8px;align-items:center">
                            <select id="deviceSelect">
                                <option value="__select__">Select a device…</option>
                                <option value="">Custom Device</option>
                            </select>
                            <span id="officialBadge" class="badge" style="display:none;white-space:nowrap"></span>
                        </div>
                        <div class="hint">
                            Select from official devices or choose "Custom
                            Device" to enter manually.
                        </div>
                    </div>

                    <div class="group" id="customFields">
                        <div class="group">
                            <label
                                >Device name</label
                            >
                            <textarea id="deviceName">
Device Name
Here</textarea
                            >
                        </div>


                            <div class="group">
                                <label>Codename</label>
                                <input type="text" id="codename" value="" />
                            </div>

                        <div class="group row">
                            <div>
                                <label>Maintainer</label>
                                <input
                                    type="text"
                                    id="maintainer"
                                    value="Maintainer"
                                />
                            </div>
                            <div>
                                <label>Manufacturer</label>
                                <input
                                    type="text"
                                    id="manufacturer"
                                    value="Manufacturer"
                                />
                            </div>
                        </div>
                    </div>

                    <div class="buttons">
                        <button id="btn-generate" type="button">
                            Generate
                        </button>
                        <button
                            id="btn-download"
                            type="button"
                            class="secondary"
                        >
                            Download PNG
                        </button>
                    </div>

                </form>
            </section>

            <!-- Preview -->
            <section class="card preview-wrap">
                <div class="preview-actions">
                    <div>
                        <span class="badge">Preview</span>
                        <span
                            id="meta"
                            class="small"
                            style="margin-left: 8px"
                        ></span>
                    </div>
                    <div class="small">
                        The generator draws a frame and text overlay; it does
                        not recreate your layout.
                    </div>
                </div>
                <div id="preview" class="preview-area">
                    <div class="small">
                        Click “Generate” to render your banner here.
                    </div>
                </div>
            </section>
        </main>

        <!-- Banner generator library -->
        <script src="../scripts/banner-generator.js"></script>
        <script>
            (function () {
                const els = {
                    deviceName: document.getElementById("deviceName"),
                        codename: document.getElementById("codename"),
                    maintainer: document.getElementById("maintainer"),
                    manufacturer: document.getElementById("manufacturer"),
                    deviceSelect: document.getElementById("deviceSelect"),
                    officialBadge: document.getElementById("officialBadge"),
                    customFields: document.getElementById("customFields"),
                    btnGenerate: document.getElementById("btn-generate"),
                    btnDownload: document.getElementById("btn-download"),
                    preview: document.getElementById("preview"),
                    meta: document.getElementById("meta"),
                };

                // Default sample template bundled in repo
                const SAMPLE_TEMPLATE = "../images/skeleton.png";

                // Cache for device list and JSON data
                const cache = {
                    deviceList: null,
                    json: new Map(),
                };

                let currentGenerateController = null;
                let fileBlobUrl = null;
                let lastResult = null;

                // Helpers to source list from device_db.json (priority) and devices.json
                async function loadJSON(url) {
                    // Check cache first
                    if (cache.json.has(url)) {
                        return cache.json.get(url);
                    }

                    const res = await fetch(url, { cache: "force-cache" });
                    if (!res.ok) throw new Error("Failed to load " + url);
                    const data = await res.json();

                    // Store in cache
                    cache.json.set(url, data);
                    return data;
                }
                async function buildDeviceList() {
                    // Return cached list if available
                    if (cache.deviceList) {
                        return cache.deviceList;
                    }

                    let db = null,
                        devices = null;
                    try {
                        db = await loadJSON("../data/device_db.json");
                    } catch (_) {}
                    try {
                        devices = await loadJSON("../data/devices.json");
                    } catch (_) {}
                    const map = new Map();

                    // device_db.json overrides first (priority), skip hidden
                    if (db && db.overrides) {
                        const entries = Object.entries(db.overrides);
                        for (let i = 0; i < entries.length; i++) {
                            const [code, entry] = entries[i];
                            if (!entry || entry.hide) continue;
                            const codename = String(
                                entry.codename || code || "",
                            ).toLowerCase();
                            if (!codename) continue;

                            map.set(codename, {
                                codename,
                                model: entry.model || "",
                                oem: entry.oem || "",
                                maintainer: entry.maintainer || "",
                                isOfficial: true, // from device_db.json
                            });

                            // Aliases are intentionally not added to the dropdown to avoid duplicates.
                        }
                    }

                    // devices.json entries (fallback if not already present)
                    if (devices && Array.isArray(devices.devices)) {
                        const devicesArray = devices.devices;
                        for (let i = 0; i < devicesArray.length; i++) {
                            const it = devicesArray[i];
                            let code = String(
                                it?.name || it?.filename || "",
                            ).toLowerCase();
                            // Strip .json extension if present
                            if (code.endsWith(".json")) {
                                code = code.slice(0, -5);
                            }
                            if (!code) continue;
                            // Only add if not already in device_db
                            if (!map.has(code)) {
                                const r = it?.data?.response;
                                map.set(code, {
                                    codename: code,
                                    model: r?.device || "",
                                    oem: r?.oem || "",
                                    maintainer: r?.maintainer || "",
                                    isOfficial: true, // found in devices.json
                                });
                            }
                        }
                    }

                    const list = Array.from(map.values()).sort((a, b) =>
                        a.codename.localeCompare(b.codename),
                    );

                    // Cache the result
                    cache.deviceList = list;
                    return list;
                }
                async function populateDeviceDropdown() {
                    if (!els.deviceSelect) return;
                    try {
                        els.deviceSelect.disabled = true;
                        els.deviceSelect.innerHTML =
                            '<option value="">Loading…</option>';
                        const list = await buildDeviceList();
                        const frag = document.createDocumentFragment();
                        const defaultOpt = document.createElement("option");
                        // Use a non-empty placeholder value so we can reserve the empty value for "Custom Device"
                        defaultOpt.value = "__select__";
                        defaultOpt.textContent = "Select a device…";
                        frag.appendChild(defaultOpt);
                        const customOpt = document.createElement("option");
                        // Keep empty string as the value for Custom Device (user requested)
                        customOpt.value = "";
                        customOpt.textContent = "Custom Device";
                        frag.appendChild(customOpt);

                        // Batch create all options at once and set data-official when known
                        const listLength = list.length;
                        for (let i = 0; i < listLength; i++) {
                            const item = list[i];
                            const opt = document.createElement("option");
                            opt.value = item.codename;
                            opt.textContent = `(${item.codename}) | ${item.model || "Unknown model"}`;
                            if (item.isOfficial) opt.dataset.official = "1";
                            frag.appendChild(opt);
                        }

                        els.deviceSelect.innerHTML = "";
                        els.deviceSelect.appendChild(frag);
                        els.deviceSelect.disabled = false;
                    } catch (e) {
                        console.error("Failed to build device list", e);
                        els.deviceSelect.innerHTML =
                            '<option value="">Failed to load list</option>';
                        els.deviceSelect.disabled = false;
                    }
                }

                function showOfficialBadge(isOfficial) {
                    if (!els.officialBadge) return;
                    if (isOfficial) {
                        els.officialBadge.style.display = "inline-block";
                        els.officialBadge.textContent = "Official build";
                    } else {
                        els.officialBadge.style.display = "none";
                        els.officialBadge.textContent = "";
                    }
                }
                function applySelectionToFields(selected) {
                    if (!selected) return;
                    // Always update fields, even if empty string
                    els.deviceName.value = selected.model || "";
                    els.manufacturer.value = selected.oem || "";
                    els.maintainer.value = selected.maintainer || "";
                }

                function setBusy(on) {
                    els.btnGenerate.disabled = on;
                    els.btnDownload.disabled = on;
                }

                function revokeFileUrl() {
                    if (fileBlobUrl) {
                        URL.revokeObjectURL(fileBlobUrl);
                        fileBlobUrl = null;
                    }
                }

                function getFilenameBase() {
                    const raw = (els.deviceName.value || "AlphaDroid")
                        .replace(/\s+/g, " ")
                        .trim();
                    const compact = raw
                        .replace(/\s+/g, "-")
                        .replace(/[^a-z0-9\-_.]/gi, "");
                    return `alphadroid-${compact || "banner"}`;
                }

                function clearPreview() {
                    els.preview.innerHTML =
                        '<div class="small">Rendering…</div>';
                }

                function showCanvas(canvas) {
                    els.preview.innerHTML = "";
                    // Ensure the canvas fills the preview container vertically while maintaining 16:9
                    // We'll use CSS sizing (not redraw) so the bitmap stays high-res.
                    canvas.style.width = "auto";
                    canvas.style.height = "100%"; // fill container height
                    canvas.style.maxWidth = "100%"; // but never overflow horizontally
                    canvas.style.display = "block";

                    els.preview.appendChild(canvas);
                    els.meta.textContent = `${canvas.width}x${canvas.height} (bitmap), CSS size: ${Math.round(canvas.getBoundingClientRect().width)}x${Math.round(canvas.getBoundingClientRect().height)} px`;

                    // Observe container resize to reapply sizing rules if needed
                    try {
                        if (window.ResizeObserver) {
                            if (els._resizeObserver) els._resizeObserver.disconnect();
                            els._resizeObserver = new ResizeObserver(() => {
                                // Ensure canvas height fills preview; width stays auto
                                canvas.style.height = "100%";
                                canvas.style.width = "auto";
                                canvas.style.maxWidth = "100%";
                                els.meta.textContent = `${canvas.width}x${canvas.height} (bitmap), CSS size: ${Math.round(canvas.getBoundingClientRect().width)}x${Math.round(canvas.getBoundingClientRect().height)} px`;
                            });
                            els._resizeObserver.observe(els.preview);
                        }
                    } catch (_) {}
                }

                function toggleCustomFields() {
                    const selectedValue = els.deviceSelect?.value?.trim() || "";
                    const isCustom = selectedValue === "";

                    if (els.customFields) {
                        els.customFields.style.display = isCustom
                            ? "block"
                            : "none";
                    }
                }

                async function generate() {
                    // Cancel any ongoing generation
                    if (currentGenerateController) {
                        currentGenerateController.abort();
                    }
                    currentGenerateController = new AbortController();
                    const thisController = currentGenerateController;

                    setBusy(true);
                    try {
                        clearPreview();
                        const width = 1920;
                        const height = 1080;
                        const quality = 1.0;
                        const dpr = 1; // Keep at 1 for consistency

                        const selectedCode =
                            els.deviceSelect?.value?.trim() || "";

                        const options = {
                            template: SAMPLE_TEMPLATE,
                            width,
                            height,
                            quality,
                            dpr,
                        };

                        // Always pass current field values, even for official devices
                        options.deviceName = els.deviceName.value;
                        options.maintainer = els.maintainer.value;
                        options.manufacturer = els.manufacturer.value;

                            // Custom devices are unofficial
                            options.isOfficial = false;

                            // Custom device: use entered codename
                            options.codename = els.codename.value;

                        if (selectedCode && selectedCode !== "") {
                            // Official device from dropdown
                            options.codename = selectedCode;
                            options.lookup = {
                                devicesUrl: "../data/devices.json",
                                deviceDbUrl: "../data/device_db.json",
                            };
                            // If the option element carries data-official, prefer it as a quick hint
                            try {
                                const opt = els.deviceSelect.selectedOptions[0];
                                if (opt && opt.dataset && opt.dataset.official === "1") {
                                    options.isOfficial = true;
                                }
                            } catch (_) {}
                        } else {
                            // Custom devices are unofficial
                            options.isOfficial = false;
                        }

                        const out = await BannerGenerator.generate(options);

                        // Check if this request was cancelled
                        if (thisController.signal.aborted) {
                            return;
                        }

                        lastResult = out;
                        showCanvas(out.canvas);
                        return out;
                    } catch (e) {
                        // Ignore abort errors
                        if (e.name === "AbortError") {
                            return;
                        }
                        console.error(e);
                        els.preview.innerHTML =
                            '<div class="small" style="color:#ff9aa2">Failed to render banner. See console for details.</div>';
                        lastResult = null;
                    } finally {
                        if (currentGenerateController === thisController) {
                            currentGenerateController = null;
                        }
                        setBusy(false);
                    }
                }

                async function download() {
                    try {
                        if (!lastResult) {
                            await generate();
                            if (!lastResult) return;
                        }
                        const name = getFilenameBase() + ".png";
                        await BannerGenerator.download(lastResult.blob, name);
                    } catch (e) {
                        console.error(e);
                    }
                }

                // Wire up actions
                els.btnGenerate.addEventListener("click", generate);
                els.btnDownload.addEventListener("click", download);

                // Populate dropdown, and reflect selection into fields
                (async () => {
                    await populateDeviceDropdown();

                    // After population, default to custom (empty value) when selection is empty or still the placeholder
                    if (!els.deviceSelect.value || els.deviceSelect.value === "__select__") {
                        els.deviceSelect.value = ""; // empty string = Custom Device
                    }

                    // Initialize badge + fields according to current selection
                    const initialOpt = els.deviceSelect.selectedOptions[0];
                    const initialOfficial = initialOpt && initialOpt.dataset.official === "1";
                    showOfficialBadge(initialOfficial);
                    toggleCustomFields();

                    if (els.deviceSelect) {
                        els.deviceSelect.addEventListener("change", async () => {
                            const code = els.deviceSelect.value;

                            let info = null;
                            if (code) {
                                try {
                                    const list = await buildDeviceList();
                                    info = list.find((d) => d.codename === code) || null;
                                } catch (_) {
                                    info = null;
                                }
                            }

                            if (code && info) {
                                // Official device: fill fields
                                applySelectionToFields(info);
                            } else if (!code) {
                                // Custom device: clear fields (but keep present in DOM)
                                els.deviceName.value = "";
                                els.maintainer.value = "";
                                els.manufacturer.value = "";
                            }

                            // Toggle visibility of custom fields AFTER applying values
                            toggleCustomFields();

                            // Update official badge based on selected option attribute
                            const opt = els.deviceSelect.selectedOptions[0];
                            const isOfficial = opt && (opt.dataset.official === "1");
                            showOfficialBadge(isOfficial);

                            // Always trigger regeneration after fields are updated
                            auto();
                        });
                    }
                })();

                // Initialize field visibility
                toggleCustomFields();

                // Auto-preview on changes (debounced)
                const debounce = (fn, wait = 400) => {
                    let t;
                    return (...args) => {
                        clearTimeout(t);
                        t = setTimeout(() => fn(...args), wait);
                    };
                };
                const auto = debounce(generate, 450);

                const autoUpdateFields = [
                    els.deviceName,
                    els.brand,
                    els.maintainer,
                    els.manufacturer,
                ];

                for (let i = 0; i < autoUpdateFields.length; i++) {
                    autoUpdateFields[i].addEventListener("input", auto, {
                        passive: true,
                    });
                }

                // Initial render - removed automatic generation
                // generate();

                // Cleanup
                window.addEventListener("beforeunload", revokeFileUrl);
            })();
        </script>
    </body>
</html>
